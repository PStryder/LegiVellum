# Receipt Protocol - Universal Coordination Primitive

**Created:** 2026-01-04  
**Status:** Core Protocol Specification  
**Purpose:** Define the universal receipt system that enables temporal resilience across the Technomancy Trilogy

---

## Core Insight

**Every meaningful action leaves a receipt. Receipts are not the work itself - they are proof that something happened, who owns it, and where to look next.**

Receipts turn time from an enemy into a neutral factor. Hours can pass. Sessions can reset. Systems can sleep. Nothing important is lost, because nothing important happens without leaving a receipt behind.

---

## What Receipts Enable

### 1. Temporal Resilience

Work survives session resets, network failures, and arbitrary delays. If a session dies after queueing work but before completion, the receipt persists. Next session: "You have work in flight from 2 hours ago."

### 2. Accountability Chains

Every outcome traces back to originating intent through an explicit chain. Not metadata soup - a proper linked graph where every receipt points upstream via `caused_by_receipt_id`.

### 3. Work-in-Flight Visibility

Root receipts (no completion pair) represent open obligations. Components can query: "What am I currently responsible for?" and get a definitive answer.

### 4. Audit Trails

External systems can reconstruct the complete decision path from symptom to root cause by walking the receipt chain.

---

## The Four Essential Questions

Every receipt answers these questions:

1. **What just happened?** (event_type, summary)
2. **Who is responsible for responding?** (recipient_ai)
3. **Where is the artifact or outcome?** (artifact_pointer, artifact_location)
4. **Does anything need to happen next?** (requires_action, suggested_next_step)

---

## Receipt Types

### Root Receipts

Represent open obligations - work that has been requested but not yet completed.

```
Format: R.{timestamp}.{component}.{reference}
Example: R.20260104_095023_450.kee.user_input_abc

Status: unpaired (until completion receipt arrives)
```

### Completion Receipts

Signal that work is done - pair with root receipts to close the loop.

```
Format: Complete.{root_receipt_id}
Example: Complete.R.20260104_095023_450.kee.user_input_abc

Status: automatically paired with root by MemoryGate
```

### Intermediate Receipts

Track work-in-progress without requiring completion - used for events like plan creation, task queueing.

```
Format: R.{timestamp}.{component}.{reference}
Example: R.20260104_095024_120.delegate.plan_xyz

Status: active (may or may not have completion depending on event type)
```

---

## Dual Identity System

Every receipt has TWO identifiers to solve different problems:

### 1. Semantic ID (receipt_id)

**Purpose:** Human-readable, encodes provenance, used in AI-visible operations

**Format:** `{type}.{timestamp}.{component}.{reference}`

**Components:**
- `type`: "R" (root/intermediate) or "Complete.R" (completion)
- `timestamp`: YYYYMMDD_HHmmss_SSS (millisecond precision)
- `component`: Originating system (kee, asyncgate, delegate, etc)
- `reference`: Contextual identifier (task_id, plan_id, user_input_id, etc)

**Examples:**
```
R.20260104_095023_450.kee.origin_abc
Complete.R.20260104_095023_450.kee.origin_abc
R.20260104_095024_120.asyncgate.task_xyz
R.20260104_095025_330.delegate.plan_def
```

**Properties:**
- Generated by emitting component at runtime
- Collision-resistant via timestamp + component + reference
- Self-documenting (who, when, what)
- Used in bootstrap, chains, audit queries

### 2. Database UUID (uuid)

**Purpose:** Collision-proof primary key, used for internal database operations

**Format:** Standard UUID v4

**Example:** `550e8400-e29b-41d4-a716-446655440000`

**Properties:**
- Auto-generated by database on INSERT
- Guaranteed globally unique
- Used for joins, foreign keys, internal indexes
- Never exposed to AI agents

### Why Both?

**Semantic IDs** enable humans and AI to reason about receipts:
- "Show me all receipts from asyncgate today"
- "Trace completion back to origin"
- "What tasks did kee queue yesterday?"

**UUIDs** enable database integrity:
- Foreign key constraints
- High-performance joins
- Collision-proof even at massive scale
- Standard database tooling compatibility

---

## Receipt Schema

### Core Fields

```json
{
    // Dual identity
    "uuid": "550e8400-e29b-41d4-a716-446655440000",
    "receipt_id": "R.20260104_095023_450.kee.origin_abc",
    
    // What happened?
    "event_type": "task_received|plan_created|task_queued|task_complete|task_failed|direct_call|aggregation|escalation",
    "summary": "Brief human-readable description",
    
    // Who owns response?
    "recipient_ai": "kee|hexy|principal|external_system",
    "source_system": "delegate|asyncgate|principal|worker",
    
    // Where is artifact?
    "artifact_pointer": "plan_xyz|task_abc|s3://bucket/key|null",
    "artifact_location": "delegate_registry|asyncgate_tasks|result_channel|null",
    
    // What's next?
    "requires_action": true|false,
    "suggested_next_step": "Execute plan steps|Wait for completion|null",
    
    // Chaining (enables provenance)
    "caused_by_receipt_id": "R.20260104_095022_100.kee.intent_root",
    
    // Pairing (enables completion tracking)
    "paired_with_uuid": "550e8400-...",
    
    // Status lifecycle
    "status": "active|complete|archived",
    
    // Deduplication
    "dedupe_key": "unique_idempotency_key",
    
    // Extensibility
    "metadata": {
        "task_id": "abc123",
        "plan_id": "plan_xyz",
        "custom_field": "value"
    },
    
    // Timestamps
    "created_at": "2026-01-04T09:50:23.450Z",
    "delivered_at": "2026-01-04T09:50:23.500Z",
    "read_at": "2026-01-04T09:50:25.100Z",
    "archived_at": null
}
```

### Database Schema

```sql
CREATE TABLE receipts (
    -- Dual identity
    uuid UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    receipt_id VARCHAR(200) UNIQUE NOT NULL,
    
    -- What happened?
    event_type VARCHAR(50) NOT NULL,
    summary TEXT NOT NULL,
    
    -- Who owns response?
    recipient_ai VARCHAR(50) NOT NULL,
    source_system VARCHAR(50) NOT NULL,
    
    -- Where is artifact?
    artifact_pointer VARCHAR(500),
    artifact_location VARCHAR(100),
    
    -- What's next?
    requires_action BOOLEAN DEFAULT FALSE,
    suggested_next_step TEXT,
    
    -- Chaining (provenance)
    caused_by_receipt_id VARCHAR(200) REFERENCES receipts(receipt_id),
    
    -- Pairing (completion tracking)
    paired_with_uuid UUID REFERENCES receipts(uuid),
    
    -- Status lifecycle
    status VARCHAR(20) DEFAULT 'active',
    
    -- Deduplication
    dedupe_key VARCHAR(200) UNIQUE NOT NULL,
    
    -- Extensibility
    metadata JSONB,
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT NOW(),
    delivered_at TIMESTAMP,
    read_at TIMESTAMP,
    archived_at TIMESTAMP,
    
    -- Indexes for common queries
    INDEX idx_unpaired (recipient_ai, status) WHERE status = 'active',
    INDEX idx_chain (caused_by_receipt_id),
    INDEX idx_pairing (paired_with_uuid),
    INDEX idx_event_type (event_type, created_at),
    INDEX idx_source_system (source_system, created_at)
);
```

---

## Chaining Semantics

### The caused_by Field

Every receipt (except root receipts from external input) should reference what caused it:

```json
{
    "receipt_id": "R.20260104_095024_120.delegate.plan_xyz",
    "caused_by_receipt_id": "R.20260104_095023_450.kee.user_input_abc",
    ...
}
```

### Chain Navigation

**Upstream (trace to origin):**
```python
def trace_to_origin(receipt_id):
    chain = []
    current = get_receipt(receipt_id)
    
    while current:
        chain.append(current)
        if current.caused_by_receipt_id:
            current = get_receipt(current.caused_by_receipt_id)
        else:
            break  # Hit root
    
    return reversed(chain)  # Root first
```

**Downstream (find consequences):**
```python
def find_consequences(receipt_id):
    return query_receipts(caused_by_receipt_id=receipt_id)
```

### Chain Properties

**Acyclic:** Chains always flow from cause to effect, never loop
**Rooted:** Every chain terminates at a root receipt (caused_by=NULL)
**Auditable:** Walk from any point to origin or leaves

---

## Pairing Semantics

### Root + Completion Pattern

Some event types form request/response pairs:

**Root receipt:**
```json
{
    "receipt_id": "R.20260104_095023_450.kee.user_input_abc",
    "event_type": "task_received",
    "status": "active",  // Unpaired
    "paired_with_uuid": null
}
```

**Completion receipt:**
```json
{
    "receipt_id": "Complete.R.20260104_095023_450.kee.user_input_abc",
    "event_type": "task_complete",
    "status": "complete",
    "paired_with_uuid": "550e8400-..."  // Points to root
}
```

### Automatic Pairing

MemoryGate automatically pairs receipts when completion arrives:

```python
# When completion receipt posted
def on_completion_receipt(completion):
    # Extract root receipt_id from completion
    root_id = extract_root_id(completion.receipt_id)
    # → "R.20260104_095023_450.kee.user_input_abc"
    
    root = get_receipt_by_id(root_id)
    
    if root:
        # Mark both as paired
        root.paired_with_uuid = completion.uuid
        root.status = 'complete'
        
        completion.paired_with_uuid = root.uuid
        completion.status = 'complete'
        
        save(root)
        save(completion)
```

### Pairing States

```
unpaired:  Root exists, no completion yet (open work)
paired:    Both root and completion exist (closed work)
orphaned:  Completion exists, but root not found (data inconsistency)
```

### Bootstrap Filtering

```python
# Bootstrap shows only unpaired (actionable) receipts
def get_inbox_receipts(recipient_ai):
    return query_receipts(
        recipient_ai=recipient_ai,
        status='active',
        paired_with_uuid=None  # Unpaired only
    )
```

---

## Event Type Taxonomy

### Boundary Crossing Events (Always Generate Receipts)

**task_received:**
- External input arrives at cognitive cluster
- Creates root receipt
- Requires completion receipt when done

**plan_created:**
- DeleGate produces structured plan
- References causing receipt
- May not require completion (depends on context)

**task_queued:**
- Work posted to AsyncGate
- Creates root receipt for async work
- Requires completion receipt (task_complete/task_failed)

**task_complete:**
- Work finished successfully
- Completes task_queued receipt
- Includes artifact pointer

**task_failed:**
- Work failed
- Completes task_queued receipt
- Includes error details

**direct_call:**
- Component calls worker directly (synchronous)
- May or may not require completion (fast calls don't)

**aggregation:**
- Principal synthesizes multiple results
- May suggest knowledge promotion

**escalation:**
- Decision passed up hierarchy
- Creates receipt for higher-tier principal

### Internal Events (No Receipts)

- Internal planning/thinking by DeleGate
- Internal synthesis by Principal
- Heartbeats, progress updates
- Cache hits, memory recalls

**Rule:** Only tier boundaries generate receipts.

---

## Lifecycle States

### active

Receipt exists, work may still be in progress.

**Characteristics:**
- Returned in bootstrap inbox
- Counted in unpaired_count (if unpaired)
- Subject to action by recipient

**Example:** Task queued but not yet complete

### complete

Work is done, receipt is paired with completion.

**Characteristics:**
- Not returned in bootstrap inbox
- Not counted in unpaired_count
- Kept for audit trail
- May be archived later

**Example:** Task completed, root + completion paired

### archived

Receipt moved to long-term storage, no longer in active query set.

**Characteristics:**
- Not returned in any active queries
- Available via explicit archive queries
- Kept for compliance/audit
- Can be moved to cold storage

**Example:** Work completed 90 days ago

### State Transitions

```
active → complete   (when paired with completion)
complete → archived (after retention period)
active → archived   (manual archive of abandoned work)
```

**Note:** No way to transition back from complete/archived to active (append-only ledger)

---

## Receipt Emission Rules

### When to Emit

**ALWAYS emit receipt when:**
- Crossing tier boundary (DeleGate → Worker, Principal → AsyncGate)
- Accepting external input (User → System)
- Completing long-running work (Worker → AsyncGate)
- Escalating decision (Domain DeleGate → Principal)

**NEVER emit receipt for:**
- Internal planning/thinking
- Progress updates, heartbeats
- Cache operations, memory reads
- Fast synchronous calls where blocking is acceptable

**Rule of thumb:** If the action creates state that must survive session reset, emit receipt.

### Boundary Crossing Examples

```
✓ DeleGate → AsyncGate.queue_task()        (tier boundary)
✓ AsyncGate → Worker (lease assignment)     (tier boundary)
✓ Worker → AsyncGate.complete()             (tier boundary)
✓ DeleGate → Worker (direct MCP call)       (tier boundary)
✓ Principal → User (task completion)        (tier boundary)

✗ DeleGate internal planning                (internal)
✗ Principal internal synthesis              (internal)
✗ MemoryGate.memory_recall()               (internal query)
✗ Worker heartbeat                          (telemetry)
```

---

## Bootstrap Integration

### Receipt Configuration Distribution

Every component bootstraps from MemoryGate and receives configuration:

```python
bootstrap = memory_bootstrap("Kee", "Claude")

{
    # Existing fields (observations, patterns, concepts)
    "observations_count": 81,
    "patterns_count": 16,
    "concepts_count": 13,
    
    # Receipt configuration (NEW)
    "receipt_config": {
        "schema_version": "1.0.0",
        "format_rules": {
            "root_pattern": "R.{timestamp}.{component}.{reference}",
            "completion_pattern": "Complete.{root_receipt_id}",
            "timestamp_format": "YYYYMMDD_HHmmss_SSS",
            "component_identifiers": ["kee", "hexy", "asyncgate", "delegate", "worker"]
        },
        "event_types": [
            "task_received", "plan_created", "task_queued", 
            "task_complete", "task_failed", "direct_call", 
            "aggregation", "escalation"
        ],
        "required_fields": [
            "receipt_id", "event_type", "recipient_ai", 
            "source_system", "summary"
        ],
        "optional_fields": [
            "artifact_pointer", "artifact_location", 
            "requires_action", "suggested_next_step"
        ]
    },
    
    # Cluster topology (NEW)
    "connected_services": {
        "memorygate_url": "https://memorygate.example.com",
        "asyncgate_url": "https://asyncgate.example.com",
        "delegate_endpoints": [
            {"delegate_id": "research", "url": "https://delegate-research.example.com"},
            {"delegate_id": "code", "url": "https://delegate-code.example.com"}
        ],
        "mcp_workers": [
            {"worker_id": "code-analyzer", "endpoint": "https://worker-code.example.com/mcp"},
            {"worker_id": "arxiv-scanner", "endpoint": "https://worker-arxiv.example.com/mcp"}
        ]
    },
    
    # Active inbox (enhanced)
    "inbox_receipts": [
        {
            "receipt_id": "R.20260104_095023_450.kee.origin_abc",
            "uuid": "550e8400-e29b-41d4-a716-446655440000",
            "event_type": "task_received",
            "summary": "Analyze codebase and suggest improvements",
            "status": "active",
            "requires_action": true,
            "created_at": "2026-01-04T09:50:23.450Z",
            "artifact_pointer": null
        }
    ],
    "unpaired_count": 1,
    
    # Session info
    "session_id": 11,
    "conversation_id": "2026-01-04-0500-morning-checkin",
    "ai_name": "Kee",
    "ai_platform": "Claude"
}
```

**Components are stateless** - everything needed to operate comes from bootstrap.

---

## MemoryGate Role

### Single Writer Principle

**HARD RULE: ONLY MemoryGate writes/reads the receipt store.**

All other components:
- POST receipts to MemoryGate (via internal API)
- GET receipts from MemoryGate (via bootstrap)
- NEVER touch receipt store directly

### Passive Ledger

MemoryGate is a ledger, not a coordinator:

**MemoryGate DOES:**
- Accept receipt POST requests
- Validate schema
- Store to receipt database
- Auto-pair completion receipts
- Return receipts in bootstrap
- Answer explicit queries

**MemoryGate DOES NOT:**
- Volunteer state updates
- Push notifications
- Coordinate work
- Make decisions
- Interpret receipt meaning

**Pattern:** Components pull state, MemoryGate never pushes.

### Receipt Submission API

```http
POST /internal/receipt
Headers:
    X-Service-Token: <shared_secret>
Content-Type: application/json

Body:
{
    "receipt_id": "R.20260104_095023_450.kee.origin_abc",
    "event_type": "task_received",
    "recipient_ai": "kee",
    "source_system": "external_system",
    "summary": "Analyze codebase and suggest improvements",
    "artifact_pointer": null,
    "artifact_location": null,
    "requires_action": true,
    "suggested_next_step": "Create plan for code analysis",
    "caused_by_receipt_id": null,
    "dedupe_key": "external_system:task_abc:v1",
    "metadata": {
        "source_user": "pstryder",
        "priority": "high"
    }
}

Response (200 OK):
{
    "status": "stored",
    "uuid": "550e8400-e29b-41d4-a716-446655440000"
}

Response (409 Conflict):
{
    "error": "duplicate_receipt",
    "existing_uuid": "550e8400-...",
    "message": "Receipt with this dedupe_key already exists"
}

Response (400 Bad Request):
{
    "error": "validation_failed",
    "field": "receipt_id",
    "message": "Invalid receipt_id format"
}
```

**Note:** Response is minimal acknowledgment only. No state information volunteered.

### Automatic Pairing Logic

When completion receipt arrives, MemoryGate automatically:
1. Extracts root receipt_id from completion receipt_id
2. Finds root receipt in database
3. Updates both receipts:
   - Sets `paired_with_uuid` cross-references
   - Sets `status = 'complete'`
4. Returns minimal acknowledgment

**This happens transparently** - caller just POSTs completion, pairing is automatic.

---

## External Audit API

External systems (compliance, monitoring, user interfaces) need read-only access to receipt chains.

### Query Receipt Chain

```http
GET /external/receipt-chain?root=R.20260104_095023_450.kee.origin_abc
Headers:
    Authorization: Bearer <external_api_token>

Response (200 OK):
{
    "root_receipt_id": "R.20260104_095023_450.kee.origin_abc",
    "status": "complete",
    "chain": [
        {
            "receipt_id": "R.20260104_095023_450.kee.origin_abc",
            "event_type": "task_received",
            "summary": "Analyze codebase and suggest improvements",
            "created_at": "2026-01-04T09:50:23.450Z",
            "caused_by_receipt_id": null
        },
        {
            "receipt_id": "R.20260104_095024_120.delegate.plan_xyz",
            "event_type": "plan_created",
            "summary": "Plan created for code analysis",
            "created_at": "2026-01-04T09:50:24.120Z",
            "caused_by_receipt_id": "R.20260104_095023_450.kee.origin_abc"
        },
        {
            "receipt_id": "R.20260104_095025_330.asyncgate.task_def",
            "event_type": "task_queued",
            "summary": "Code analysis task queued",
            "created_at": "2026-01-04T09:50:25.330Z",
            "caused_by_receipt_id": "R.20260104_095024_120.delegate.plan_xyz"
        },
        {
            "receipt_id": "Complete.R.20260104_095025_330.asyncgate.task_def",
            "event_type": "task_complete",
            "summary": "Code analysis complete",
            "created_at": "2026-01-04T10:05:15.220Z",
            "paired_with": "R.20260104_095025_330.asyncgate.task_def"
        },
        {
            "receipt_id": "Complete.R.20260104_095023_450.kee.origin_abc",
            "event_type": "task_complete",
            "summary": "Analysis complete, suggestions provided",
            "created_at": "2026-01-04T10:05:20.100Z",
            "paired_with": "R.20260104_095023_450.kee.origin_abc"
        }
    ],
    "completion_timestamp": "2026-01-04T10:05:20.100Z",
    "total_duration_seconds": 897
}
```

### Query Work In Flight

```http
GET /external/work-in-flight?recipient_ai=kee
Headers:
    Authorization: Bearer <external_api_token>

Response (200 OK):
{
    "recipient_ai": "kee",
    "unpaired_receipts": [
        {
            "receipt_id": "R.20260104_095023_450.kee.origin_abc",
            "event_type": "task_received",
            "summary": "Analyze codebase and suggest improvements",
            "created_at": "2026-01-04T09:50:23.450Z",
            "age_seconds": 1234
        }
    ],
    "count": 1
}
```

### Query by Event Type

```http
GET /external/receipts?event_type=task_failed&since=2026-01-04T00:00:00Z
Headers:
    Authorization: Bearer <external_api_token>

Response (200 OK):
{
    "event_type": "task_failed",
    "since": "2026-01-04T00:00:00Z",
    "receipts": [
        {
            "receipt_id": "Complete.R.20260104_083012_550.asyncgate.task_xyz",
            "summary": "Model API timeout after 3 retries",
            "created_at": "2026-01-04T08:35:45.120Z",
            "metadata": {
                "error": "Connection timeout",
                "retry_count": 3
            }
        }
    ],
    "count": 1
}
```

---

## Concrete Flow Examples

### Example 1: Simple Task (No Delegation)

**Scenario:** User asks X to perform simple calculation

```
1. User → X: "Calculate 2+2"

X emits root receipt:
{
    "receipt_id": "R.20260104_100000_000.kee.user_calc_1",
    "event_type": "task_received",
    "recipient_ai": "kee",
    "requires_action": true,
    "caused_by_receipt_id": null
}

2. X performs calculation internally (no tier crossing, no receipt)

3. X → User: "4"

X emits completion:
{
    "receipt_id": "Complete.R.20260104_100000_000.kee.user_calc_1",
    "event_type": "task_complete",
    "recipient_ai": "external_system",
    "artifact_pointer": "inline:4"
}

MemoryGate auto-pairs, marks complete
```

**Receipt chain:**
```
R.20260104_100000_000.kee.user_calc_1 (root)
  └─ Complete.R.20260104_100000_000.kee.user_calc_1 (paired)
```

**Result:** 2 receipts, 1 pair, simple accountability

### Example 2: Delegated Planning

**Scenario:** User asks X to analyze codebase, X delegates to DeleGate

```
1. User → X: "Analyze codebase"

X emits root receipt:
{
    "receipt_id": "R.20260104_100000_000.kee.user_task_2",
    "event_type": "task_received",
    "recipient_ai": "kee",
    "requires_action": true
}

2. X → DeleGate: "Create plan for code analysis"

(Internal call, no receipt - X and DeleGate in same tier)

3. DeleGate creates plan, emits receipt:
{
    "receipt_id": "R.20260104_100001_500.delegate.plan_abc",
    "event_type": "plan_created",
    "recipient_ai": "kee",
    "caused_by_receipt_id": "R.20260104_100000_000.kee.user_task_2",
    "artifact_pointer": "plan_abc",
    "artifact_location": "delegate_registry"
}

4. X executes plan (see next example for execution details)

5. X → User: "Analysis complete"

X emits completion:
{
    "receipt_id": "Complete.R.20260104_100000_000.kee.user_task_2",
    "event_type": "task_complete",
    "recipient_ai": "external_system"
}
```

**Receipt chain:**
```
R.20260104_100000_000.kee.user_task_2 (root)
  ├─ R.20260104_100001_500.delegate.plan_abc (plan created)
  └─ Complete.R.20260104_100000_000.kee.user_task_2 (paired)
```

**Result:** 3 receipts, 1 pair, plan artifact tracked

### Example 3: Async Execution via AsyncGate

**Scenario:** Plan includes long-running task that must go through AsyncGate

```
1. User → X: "Index all documents"

X emits root:
{
    "receipt_id": "R.20260104_100000_000.kee.user_task_3",
    "event_type": "task_received",
    "requires_action": true
}

2. X creates plan (receipt emitted as in Example 2)

3. X executes plan step: queue async work

X → AsyncGate: queue_task(task_type="document_index", ...)

AsyncGate emits receipt:
{
    "receipt_id": "R.20260104_100002_750.asyncgate.task_xyz",
    "event_type": "task_queued",
    "recipient_ai": "kee",
    "caused_by_receipt_id": "R.20260104_100001_500.delegate.plan_abc",
    "artifact_pointer": "task_xyz",
    "artifact_location": "asyncgate_tasks",
    "requires_action": false,  // No action until completion
    "suggested_next_step": "Wait for completion receipt"
}

4. X session ends (work continues in background)

5. Worker leases task, executes

(Worker ↔ AsyncGate coordination happens, no receipts - internal to AsyncGate tier)

6. Worker completes task

Worker → AsyncGate: complete_task(result_pointer="s3://bucket/index.json")

AsyncGate emits completion:
{
    "receipt_id": "Complete.R.20260104_100002_750.asyncgate.task_xyz",
    "event_type": "task_complete",
    "recipient_ai": "kee",
    "artifact_pointer": "s3://bucket/index.json",
    "artifact_location": "s3"
}

MemoryGate auto-pairs task_queued ↔ task_complete

7. X next session: bootstrap shows completion receipt

X fetches result, processes, completes user task

X emits final completion:
{
    "receipt_id": "Complete.R.20260104_100000_000.kee.user_task_3",
    "event_type": "task_complete",
    "recipient_ai": "external_system"
}
```

**Receipt chain:**
```
R.20260104_100000_000.kee.user_task_3 (root)
  ├─ R.20260104_100001_500.delegate.plan_abc (plan)
  │    └─ R.20260104_100002_750.asyncgate.task_xyz (queued)
  │         └─ Complete.R.20260104_100002_750.asyncgate.task_xyz (paired)
  └─ Complete.R.20260104_100000_000.kee.user_task_3 (paired)
```

**Result:** 5 receipts, 2 pairs, async work survived session reset

### Example 4: Escalation to Higher Tier

**Scenario:** Domain DeleGate completes work, escalates to Principal for decision

```
1. Principal → Domain DeleGate: "Research market trends"

Domain DeleGate emits receipt:
{
    "receipt_id": "R.20260104_100000_000.domain.principal_task_4",
    "event_type": "task_received",
    "recipient_ai": "domain_delegate_research",
    "requires_action": true
}

2. Domain DeleGate executes research (async work, receipts emitted)

3. Domain DeleGate completes internal work

Domain DeleGate emits completion to self:
{
    "receipt_id": "Complete.R.20260104_100000_000.domain.principal_task_4",
    "event_type": "task_complete",
    "recipient_ai": "domain_delegate_research"
}

4. Domain DeleGate escalates to Principal

Domain DeleGate creates NEW receipt for Principal:
{
    "receipt_id": "R.20260104_100510_000.domain.escalation_xyz",
    "event_type": "escalation",
    "recipient_ai": "principal",
    "summary": "Market research complete, decision required",
    "caused_by_receipt_id": "Complete.R.20260104_100000_000.domain.principal_task_4",
    "artifact_pointer": "s3://bucket/research_summary.json",
    "requires_action": true,
    "suggested_next_step": "Review findings and decide on market entry"
}

5. Principal reviews, makes decision, marks escalation complete

Principal emits:
{
    "receipt_id": "Complete.R.20260104_100510_000.domain.escalation_xyz",
    "event_type": "task_complete",
    "recipient_ai": "domain_delegate_research",
    "metadata": {"decision": "proceed", "rationale": "..."}
}
```

**Receipt chain:**
```
R.20260104_100000_000.domain.principal_task_4 (root)
  ├─ [async work receipts...]
  ├─ Complete.R.20260104_100000_000.domain.principal_task_4 (paired)
  └─ R.20260104_100510_000.domain.escalation_xyz (escalation)
       └─ Complete.R.20260104_100510_000.domain.escalation_xyz (paired)
```

**Key point:** Escalation creates NEW receipt with new owner (upward routing), not shared visibility.

---

## Receipt Best Practices

### 1. Emit Receipts Early

Don't wait until work completes to emit root receipt. Emit as soon as obligation is accepted.

**Good:**
```python
def accept_task(task):
    # Emit immediately
    receipt_id = emit_receipt(
        event_type="task_received",
        summary=task.description
    )
    
    # Then do work
    perform_work(task)
```

**Bad:**
```python
def accept_task(task):
    # Do work first
    result = perform_work(task)
    
    # Then emit (if session dies, work is lost)
    emit_receipt(...)
```

### 2. Include Meaningful Summaries

Summaries should be human-readable and specific.

**Good:**
```
"Analyze Python codebase at /path/to/repo for complexity issues"
"Query 3 AI models (GPT-4, Claude, DeepSeek) for code suggestions"
```

**Bad:**
```
"Task received"
"Work complete"
```

### 3. Use Artifact Pointers

Always include where to find the result.

**Good:**
```json
{
    "artifact_pointer": "s3://bucket/analysis_results.json",
    "artifact_location": "s3"
}
```

**Bad:**
```json
{
    "artifact_pointer": null,
    "artifact_location": null
}
```

### 4. Chain Receipts Properly

Always set `caused_by_receipt_id` for non-root receipts.

**Good:**
```json
{
    "receipt_id": "R.20260104_100002_750.asyncgate.task_xyz",
    "caused_by_receipt_id": "R.20260104_100001_500.delegate.plan_abc"
}
```

**Bad:**
```json
{
    "receipt_id": "R.20260104_100002_750.asyncgate.task_xyz",
    "caused_by_receipt_id": null  // Lost provenance
}
```

### 5. Emit Completions

Don't forget to emit completion receipts for root receipts.

**Incomplete (bad):**
```
R.20260104_100000_000.kee.user_task (unpaired forever)
```

**Complete (good):**
```
R.20260104_100000_000.kee.user_task
Complete.R.20260104_100000_000.kee.user_task (paired)
```

---

## Integration with Trilogy Components

### MemoryGate

**Role:** Receipt store implementation + bootstrap provider

**Responsibilities:**
- Accept receipt POST requests
- Validate schema
- Store to database
- Auto-pair completions
- Return receipts in bootstrap
- Provide external audit API

**Does NOT:**
- Coordinate work
- Push notifications
- Interpret receipt semantics
- Make decisions

### AsyncGate

**Role:** Task orchestration + receipt emitter

**Emits receipts for:**
- `task_queued` when queue_task() called
- `task_complete` when worker completes
- `task_failed` when worker fails or retries exhausted

**Receipt examples:**
```json
// When task queued
{
    "receipt_id": "R.{timestamp}.asyncgate.{task_id}",
    "event_type": "task_queued",
    "artifact_pointer": "{task_id}",
    "artifact_location": "asyncgate_tasks"
}

// When task completes
{
    "receipt_id": "Complete.R.{timestamp}.asyncgate.{task_id}",
    "event_type": "task_complete",
    "artifact_pointer": "{result_pointer}",
    "artifact_location": "{result_channel}"
}
```

### DeleGate

**Role:** Plan generator + receipt emitter

**Emits receipts for:**
- `plan_created` when plan is generated

**Receipt example:**
```json
{
    "receipt_id": "R.{timestamp}.delegate.{plan_id}",
    "event_type": "plan_created",
    "artifact_pointer": "{plan_id}",
    "artifact_location": "delegate_registry",
    "requires_action": true,
    "suggested_next_step": "Execute plan steps"
}
```

### Principal AI

**Role:** Plan executor + synthesizer + receipt emitter

**Emits receipts for:**
- `task_received` when accepting external input
- `aggregation` when synthesizing results
- `escalation` when passing decisions up (if in hierarchy)
- `task_complete` when finishing user tasks

**Receipt examples:**
```json
// External input
{
    "receipt_id": "R.{timestamp}.{principal}.{input_id}",
    "event_type": "task_received",
    "requires_action": true
}

// Completion
{
    "receipt_id": "Complete.R.{timestamp}.{principal}.{input_id}",
    "event_type": "task_complete",
    "recipient_ai": "external_system"
}
```

### Workers

**Role:** Task executors (do NOT emit receipts directly)

**Receipt flow:**
- Worker leases from AsyncGate (internal coordination, no receipt)
- Worker executes (internal work, no receipt)
- Worker calls AsyncGate.complete() → AsyncGate emits receipt

**Workers never POST receipts to MemoryGate directly** - AsyncGate is the tier boundary.

---

## Security & Access Control

### Internal API Authentication

Receipt submission endpoint requires service authentication:

```http
POST /internal/receipt
Headers:
    X-Service-Token: <shared_secret>
```

**Service tokens:**
- Shared secrets between MemoryGate and each component
- Rotated periodically
- Scoped to source_system (asyncgate token != delegate token)

### External API Authentication

Audit API requires external API keys:

```http
GET /external/receipt-chain?root=...
Headers:
    Authorization: Bearer <external_api_token>
```

**API tokens:**
- OAuth 2.0 or API key based
- Rate limited
- Can be scoped to specific receipt types or recipients

### Data Visibility

**Receipts contain sensitive information:**
- Who performed actions (source_system, recipient_ai)
- What work was done (event_type, summary)
- Where artifacts are (artifact_pointer)

**Access control rules:**
- Components can only query their own receipts (recipient_ai filter)
- External audit API may have broader access (compliance use case)
- Metadata fields can contain sensitive data (encrypt if needed)

---

## Monitoring & Observability

### Key Metrics

**Receipt volume:**
- Receipts/second by event_type
- Receipts/second by source_system
- Total receipts stored

**Pairing metrics:**
- Unpaired receipt count (work in flight)
- Average time to pairing (task latency)
- Orphaned completions (data inconsistency)

**Chain depth:**
- Average chain length (complexity indicator)
- Max chain depth (potential issue indicator)

**Lifecycle metrics:**
- Active receipts count
- Complete receipts count
- Archived receipts count
- Archive rate

### Alerting Conditions

**High unpaired count:**
- Threshold: >100 unpaired receipts for single recipient
- Indicates: Work backlog or stuck processing

**Old unpaired receipts:**
- Threshold: Unpaired receipt >24 hours old
- Indicates: Abandoned work or missing completion

**Orphaned completions:**
- Condition: Completion receipt with no matching root
- Indicates: Data inconsistency or out-of-order arrival

**High archive rate:**
- Threshold: >1000 receipts archived/hour
- Indicates: Possible data retention issue

---

## Data Retention & Archiving

### Retention Policies

**Active receipts:**
- Retained indefinitely while status='active'
- Returned in bootstrap queries
- Subject to action by recipient

**Complete receipts:**
- Retained for 90 days after pairing
- Available for audit queries
- Not returned in bootstrap

**Archived receipts:**
- Moved to cold storage after 90 days
- Kept for compliance (1-7 years depending on regulations)
- Queryable via special archive API

### Archiving Process

**Automatic archiving:**
```sql
-- Daily job: Archive old complete receipts
UPDATE receipts
SET status = 'archived',
    archived_at = NOW()
WHERE status = 'complete'
  AND created_at < NOW() - INTERVAL '90 days';
```

**Manual archiving:**
```python
# Admin can manually archive specific receipts
archive_receipt(receipt_id, reason="abandoned_work")
```

### Cold Storage

Archived receipts moved to separate storage:
- Object storage (S3/R2) for compliance
- Compressed and encrypted
- Indexed for retrieval if needed
- Cheaper storage tier

---

## Migration & Versioning

### Schema Evolution

Receipt schema may evolve over time. Version field enables gradual migration:

```json
{
    "receipt_id": "...",
    "schema_version": "1.0.0",
    ...
}
```

**Backward compatibility:**
- New fields are optional
- Existing fields never removed (deprecated instead)
- Components check schema_version in bootstrap

**Migration example:**
```
Version 1.0 → 1.1: Added "priority" field
- Old components ignore priority
- New components use priority if present
- No breaking changes
```

### Component Compatibility

Bootstrap includes schema version:

```python
bootstrap['receipt_config']['schema_version'] = "1.1.0"
```

Components can check:
```python
if parse_version(bootstrap['receipt_config']['schema_version']) >= parse_version("1.1.0"):
    # Use priority field
    emit_receipt(..., priority=5)
else:
    # Omit priority field
    emit_receipt(...)
```

---

## Error Handling

### Receipt Submission Failures

**Duplicate receipt (409 Conflict):**
```python
try:
    post_receipt(receipt)
except DuplicateReceipt as e:
    # Already submitted, idempotent success
    logger.info(f"Receipt already exists: {e.existing_uuid}")
```

**Validation failure (400 Bad Request):**
```python
try:
    post_receipt(receipt)
except ValidationError as e:
    # Fix receipt and retry
    logger.error(f"Invalid receipt: {e.message}")
    receipt = fix_receipt(receipt, e.field)
    post_receipt(receipt)
```

**MemoryGate unavailable (503 Service Unavailable):**
```python
try:
    post_receipt(receipt)
except ServiceUnavailable:
    # Queue locally, retry later
    local_queue.enqueue(receipt)
    schedule_retry(receipt_id, delay=30)
```

### Missing Root Receipts

If completion arrives before root:

```python
# Completion posted first
post_receipt({
    "receipt_id": "Complete.R.20260104_100000_000.kee.task_x",
    ...
})

# MemoryGate stores but cannot pair yet
# Status: orphaned_completion

# Root arrives later
post_receipt({
    "receipt_id": "R.20260104_100000_000.kee.task_x",
    ...
})

# MemoryGate retroactively pairs
# Status: complete
```

### Chain Validation

Detect broken chains:

```python
def validate_chain(receipt_id):
    receipt = get_receipt(receipt_id)
    
    if receipt.caused_by_receipt_id:
        parent = get_receipt(receipt.caused_by_receipt_id)
        if not parent:
            alert(f"Broken chain: {receipt_id} references missing {receipt.caused_by_receipt_id}")
```

---

## Testing Strategies

### Unit Testing Receipts

**Test receipt generation:**
```python
def test_receipt_generation():
    receipt = generate_receipt(
        event_type="task_queued",
        recipient_ai="kee",
        source_system="asyncgate"
    )
    
    assert receipt.receipt_id.startswith("R.")
    assert "asyncgate" in receipt.receipt_id
    assert receipt.requires_action == False
```

**Test pairing logic:**
```python
def test_automatic_pairing():
    # Post root
    root = post_receipt({
        "receipt_id": "R.20260104_100000_000.kee.test",
        ...
    })
    
    # Post completion
    completion = post_receipt({
        "receipt_id": "Complete.R.20260104_100000_000.kee.test",
        ...
    })
    
    # Verify pairing
    root_updated = get_receipt(root.receipt_id)
    assert root_updated.status == 'complete'
    assert root_updated.paired_with_uuid == completion.uuid
```

### Integration Testing

**Test end-to-end flow:**
```python
def test_complete_task_flow():
    # User input
    root = emit_receipt("task_received", "Analyze code")
    
    # Plan created
    plan = emit_receipt("plan_created", caused_by=root.receipt_id)
    
    # Task queued
    task = emit_receipt("task_queued", caused_by=plan.receipt_id)
    
    # Task complete
    task_done = emit_receipt("task_complete", pairs_with=task.receipt_id)
    
    # User task complete
    root_done = emit_receipt("task_complete", pairs_with=root.receipt_id)
    
    # Verify chain
    chain = get_receipt_chain(root.receipt_id)
    assert len(chain) == 5
    
    # Verify all paired
    bootstrap = memory_bootstrap("kee", "Claude")
    assert bootstrap['unpaired_count'] == 0
```

### Load Testing

**Test receipt throughput:**
```python
def test_receipt_throughput():
    start = time.time()
    
    # Submit 10,000 receipts
    for i in range(10000):
        post_receipt(generate_test_receipt(i))
    
    duration = time.time() - start
    throughput = 10000 / duration
    
    assert throughput > 100  # receipts/second
```

---

## Frequently Asked Questions

### Q: Why both semantic IDs and UUIDs?

**A:** Semantic IDs (receipt_id) are for humans and AI - they encode provenance and enable reasoning. UUIDs are for databases - they guarantee uniqueness and enable efficient joins. Both serve different purposes.

### Q: What if a component restarts mid-task?

**A:** Receipt already emitted to MemoryGate persists. On restart, component bootstraps and sees unpaired receipt. Can resume or retry based on receipt state.

### Q: Can receipts be deleted?

**A:** No. Receipts are append-only ledger. They can be archived (hidden from active queries) but never deleted. This ensures complete audit trail.

### Q: What if MemoryGate is down?

**A:** Components should queue receipts locally and retry. Work can continue (AsyncGate still coordinates workers), but receipts won't be visible until MemoryGate recovers.

### Q: How to handle out-of-order receipt arrival?

**A:** MemoryGate handles this via caused_by and pairing logic. Completion can arrive before root (orphaned_completion status), will auto-pair when root arrives.

### Q: What's the difference between archived and complete?

**A:** Complete means work is done and paired. Archived means moved to cold storage for compliance. Complete receipts are still queryable; archived receipts require special archive API.

### Q: Can one receipt cause multiple child receipts?

**A:** Yes. A plan creation receipt can cause multiple task_queued receipts (parallel work). Chain forms tree structure, not linear.

### Q: Do all receipts require completion?

**A:** No. Only receipts representing work that will eventually finish require completion. Intermediate receipts (plan_created, escalation) may not need completion depending on semantics.

---

## Conclusion

**Receipts are the temporal resilience primitive that makes the Technomancy Trilogy work.**

Without receipts:
- Sessions reset → work is lost
- Async work → no way to reconnect
- Failures → no audit trail
- Scale → coordination chaos

With receipts:
- Sessions reset → bootstrap shows unpaired work
- Async work → pointers survive, inbox notifies
- Failures → complete chain to root cause
- Scale → every action accountable

**Receipts turn time from an enemy into a neutral factor.**

Hours can pass. Sessions can reset. Systems can sleep.

Nothing important is lost, because nothing important happens without leaving a receipt behind.

---

## Appendix: Complete Schema Reference

### Minimal Valid Receipt

```json
{
    "receipt_id": "R.20260104_095023_450.kee.origin_abc",
    "event_type": "task_received",
    "recipient_ai": "kee",
    "source_system": "external",
    "summary": "Brief description",
    "dedupe_key": "unique_key"
}
```

### Fully-Populated Receipt

```json
{
    "uuid": "550e8400-e29b-41d4-a716-446655440000",
    "receipt_id": "R.20260104_095023_450.kee.origin_abc",
    "event_type": "task_queued",
    "summary": "Code analysis task queued for background processing",
    "recipient_ai": "kee",
    "source_system": "asyncgate",
    "artifact_pointer": "task_abc123",
    "artifact_location": "asyncgate_tasks",
    "requires_action": false,
    "suggested_next_step": "Wait for completion receipt",
    "caused_by_receipt_id": "R.20260104_095022_100.delegate.plan_xyz",
    "paired_with_uuid": null,
    "status": "active",
    "dedupe_key": "asyncgate:task_queued:abc123:v1",
    "metadata": {
        "task_type": "code_analysis",
        "estimated_duration_seconds": 300,
        "priority": 5
    },
    "created_at": "2026-01-04T09:50:23.450Z",
    "delivered_at": "2026-01-04T09:50:23.500Z",
    "read_at": null,
    "archived_at": null
}
```

### Event Type Reference

| Event Type | Requires Completion | Typical Source | Description |
|-----------|-------------------|---------------|-------------|
| task_received | Yes | Principal | External input accepted |
| plan_created | No | DeleGate | Plan generated |
| task_queued | Yes | AsyncGate | Work queued for async execution |
| task_complete | Pairs with root | AsyncGate/Principal | Work finished successfully |
| task_failed | Pairs with root | AsyncGate | Work failed |
| direct_call | Optional | Principal | Synchronous worker call |
| aggregation | Optional | Principal | Results synthesized |
| escalation | Yes | DeleGate | Decision passed up tier |

---

*Protocol documented: 2026-01-04*  
*Purpose: Universal coordination primitive for Technomancy Trilogy*  
*Enables: Temporal resilience, accountability chains, work-in-flight visibility, audit trails*